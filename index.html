<html>

<head>
  <style>
  
  .gridlines line {
    stroke: #bbb;
  }
  
  .gridlines .domain {
    stroke: none;
  }

  </style>
</head>
  
<body style="margin: 75">
  <h3>
    Olympic Water Sports
    <script src="https://d3js.org/d3.v7.min.js"></script>
  </h3>
  <p>
    <b>Title</b>
    <br />
    <svg height=500 width=500 style="border:1px solid black; margin-bottom:50px;"></svg>
    <script>
      // Coastlines Mappings
      let coastlines = new Map()
      let maxCoast = 0;

      d3.csv('../data/coastlines.csv').then( (data) => {
        data.forEach( (d, i) => {
          coastlines.set(d.country, d.coastline_wf);
          maxCoast = Math.max(maxCoast, d.coastline_wf);
        })
      })

      console.log(coastlines);

      // Chart Area

      const svg = d3.select('svg');
      const width = svg.attr('width');
      const height = svg.attr('height');
      const margins = {top: 10, right: 10, bottom: 50, left: 50};
      const chartWidth = width - margins.left - margins.right;
      const chartHeight = height - margins.top - margins.bottom;

      let chartArea = svg.append('g')
                         .attr('transform',`translate(${margins.left},${margins.top})`);

      d3.csv('../data/water_sports.csv').then( (data) => {

        // Medal Counts

        let medal_counts = new Map();

        data.forEach( (d, i) => {
          if (medal_counts.has(d.country)) {
            medal_counts.set(d.country, medal_counts.get(d.country) + 1)
          } else {
            medal_counts.set(d.country, 1);
          }
        })

        console.log(medal_counts);
        console.log(medal_counts.size);
        console.log(maxCoast);

        // Extents and Scales
        // const xExtent = d3.extent(data, d => d['Release Day'] );
        const xScale = d3.scaleLinear().domain([0, medal_counts.size])
                                       .range([0, chartWidth]);
      
        // const yExtent = d3.extent(data, d => d['Transistors(million)'] );
        const yScale = d3.scaleLinear().domain([0, maxCoast])
                                       .range([chartHeight, 0]);
        
        // Axes

        let leftAxis = d3.axisLeft(yScale);
        svg.append('g')
           .attr("class", "axis")
           .attr('transform',`translate(${margins.left-10},${margins.top})`) 
           .call(leftAxis);

        let bottomAxis = d3.axisBottom(xScale);
        svg.append('g')
           .attr('class', 'axis')
           .attr('transform',`translate(${margins.left},${chartHeight+margins.top+10})`)
           .call(bottomAxis);

        // Gridlines
        
        let leftGridlines = d3.axisLeft(yScale)
                              .tickSize(-chartWidth-10)
                              .tickFormat('');
        svg.append('g')
           .attr("class", "gridlines")
           .attr('transform',`translate(${margins.left-10},${margins.top})`)
           .call(leftGridlines);        
        
        let bottomGridlines = d3.axisBottom(xScale)
                      .tickSize(-chartHeight-10)
                      .tickFormat('');
        svg.append('g')
           .attr("class", "gridlines")
           .attr('transform',`translate(${margins.left},${chartHeight+margins.top+10})`)
           .call(bottomGridlines);

        // Circles

        // data.forEach( (d, i) => {

        // chartArea.append('circle')
        //     .attr('cx', xScale(d['Release Day']))
        //     .attr('cy', yScale(d['Transistors(million)']))
        //     .attr('r', 3)
        //     .attr('opacity', 0.3)
        //     .attr('index', i)
        //     .style('fill', '#00008B');

        // });
      });

    </script>

  </p>
</body>

</html>